---
title: 'index 기본개념'
date: 2023-09-27 22:19:00
category: 'database'
draft: false
---

> index 기본개념

# RDS 에서 사용하는 인덱스눈 구조에 따라 크게 3가지로 분류 가능
## 1. B-tree 인덱스(B+tree)
- B-tree 인덱스는 이름 그대로 데이터를 트리 구조로 저장하는 형태의 인덱스
- 균형잡힌 뛰어난 범용성을 인정받아 가장 많이 사용된다. 
	- 보통 인덱스라고 말하면, 대부분 B-tree 인덱스를 지칭하는 것이다.
	- 실제로 특별한 수식 붙이지 않은 채 CREATE INDEX 구문을 실행하면, 모든 DBMS 에서 암묵적으로 B-tree 인덱스가 만들어짐

- 검색 알고리즘이 가장 뛰어나게 성능이 좋은 것은 아니지만, 균형이 잘 잡혀있기 때문.
- 사실 대부분의 데이터베이스는 트리의 리프 노드에만 키값을 저장하는 B+tree라는, B-tree의 수정 버전을 채택한다.(Mysql 포함)
- 이는 B-tree에 비해 검색을 보다 효율적으로 만든 알고리즘으로, 데이터베이스 외에 파일 시스템 등에서도 사용된다.
- B+tree 검색 성능이 뛰어난 이유
	- 루트와 리프의 거리를 가능한 일정하게 유지하려 한다. 따라서 균형이 잘 잡혀 검색 성능이 안정적
	- 트리의 깊이도 대개 3-4정도의 수준으로 일정할 뿐 아니라, 데이터가 정렬 상태를 유지하므로 이분 탐색을 통해 검색 비용을 크게 줄일 수 있다.
	- 데이터가 정렬되어 있는 만큼 잘만 활용하면 집약 함수 등에서도 요구되는 정렬을 하지 않은 채 넘어갈 수도 있다.

## 2. 비트맵 인덱스
- 데이터를 비트 플래그로 변환해서 저장하는 형태의 인덱스로, 카디널리티가 낮은 필드에 대해 효과를 발휘한다.
- 하지만, 갱신할 때 오버헤드가 너무 크기 때문에 빈번한 갱신이 일어나지 않는 BI/DWH 용도로 사용된다.
## 3. 해시 인덱스 
- 키를 해시 분산해서 등가 검색을 고속으로 시랭하고자 만들어진 인덱스
- 하지만 등가 검색 외에는 효과가 거의 없고 범위 검색을 할 수 없다는 점 때문에 거의 사용되지 않는다. 


# 인덱스 활용법(B+tree)
- B+tree의 장점은 범용성이다.
	- 키값 사이에 검색 속도의 불균형이 거의 없으므로 데이터양이 증가해도 검색 속도가 갑자기 약화하는 일이 없다.
	- 등호(=) 뿐만 아니라 부등호(>, <, >=, <=) 를 사용한 검색 조건에서도 사용할 수 있다.

## 1. 카디널리티와 선택률
- 인덱스는 테이블의 특정 필드집합에 대해 만든다. 이 때, 어떤 필드에 대해 인덱스를 작성할 것인지 기준이 되는 요소가 필드의 `카디널리티`와 `선택률`이다.
- 카디널리티
	- 값의 균형.
	- 카디널리티가 가장 높다 -> 모든 레코드에 다른 값이 들어가있는 경우. 유일 키 필드.
	- 카디널리티가 가장 낮다 -> 모든 레코드에 같은 값이 들어가있는 경우.

- 선택률
	- 특정 필드값을 지정했을 경우 테이블 전체에서 몇 개의 레코드가 선택되는지 나타내는 개념.
	- 예를 들어, 100개의 레코드를 가진 테이블에서 유일키로 'pkey=1' 처럼 등호를 지정한다면 한 개의 레코드가 선택될 것이므로 `1/100 = 0.01로 선택률은 1%`

- 클러스터링 팩터(참고만)
	- 인덱스의 성능을 결정하는 요인.
	- 저장소에 같은 값이 어느 정도 물리적으로 뭉쳐 존재하는지 나타내는 지표. 높을수록 분산, 낮을수록 뭉쳐있음.
	- 인덱스로 접근할 때는 특정 값에만 접근하는 경우가 많으므로 보통 클러스터링 팩터가 낮을수록 접근할 데이터양이 적어져 좋다.


## 2. 인덱스를 사용하는 것이 좋은지 판단하려면
- 인덱스를 작성하는 필드 집합의 조건은 두 가지 지표로 판단한다. 
1. 카디널리티가 높을 것.
	- 값이 평균치에서 많이 흩어져있을수록 좋은 후보
2. 선택률이 낮을 것.
	- 한 번의 선택으로 레코드가 조금만 선택되는 것이 좋은 후보
	- 최근 DBMS에서는 대체로 5~10% 이하가 기준. 
	- 따라서 5% 미만이라면 해당 필드 집합은 인덱스를 작성할 가치가 있다.
	- 선택률이 10%보다 높다면 테이블 풀 스캔을 하는 편이 더 빠를 가능성이 커진다.


# 인덱스로 성능 향상이 어려운 경우

## 1. 압축 조건이 존재하지 않음.
- 1억건의 데이터가 있는 Orders 테이블이 있다고 하자.
```sql
SELECT order_id, receive_date
FROM Orders;
```

- 위의 쿼리는 실행 계획 없어도 테이블 풀 스캔이라는 것을 알 수 있다.
- 레코드를 압축하는 WHERE 구가 애시당초 없으므로 인덱스를 작성할만한 필드도 존재하지 않는다.
- 그런데 실무에서는 이런 극단적인 경우가 잘 없다. 

## 2. 레코드를 제대로 압축하지 못하는 경우
- 압축조건이 있기는 하지만 레코드를 압축하지 못하는 경우
```sql
SELECT order_id, receive_date
FROM Orders
WHERE process_flag = '5';
```
- Orders 테이블에서 process_flg의 분포가 다음과 같다고 가정해보자.
	- 1(주문단계) : 200만 건
	- 2(주문완료) : 500만 건
	- 3(재고확인중) : 500만 건
	- 4(배송준비중) : 500만 건
	- 5(배송완료) : 8,300만 건

- `process_flag = '5'` 라는 검색 조건은 존재하지만, 이 조건만으로 레코드 절반 이상이 선택된다. 선택률이 83%로 매우 높은 수치.
- 이 상태에서 process_flg 필드에 인덱스를 만들면, 설령 그것을 사용하더라도 풀 스캔을 할 때보다 느려질 가능성이 높다. 결국 역효과만 발생하는 것.
- 인덱스가 제대로 작동하려면 어디까지나 `레코드를 크게 압축할 수 있는 조건` 이 있어야 한다.
- 이처럼 필드명이 _flg 또는 _status 가 붙은 필드는 특정 종류만을 지정하는 경우가 많다.(종류의 수가 적으므로). 인덱스로 만들기에 ㅓㅈㄱ절하지 않다.
